---
title: FMQ之事务消息
date: 2018-04-08 14:40:13
tags:
- 中间件
- 消息队列
categories: 编程
comments: true
---
*事务消息是指帮用户实现类似XA的分布式事务功能。*
<!--more-->

# 1 概述

## 1.1 分布式事务

如果事务的参与者、支持事务的服务器及资源分别位于不同的分布式系统的不同节点之上，那就称为分布式事务。一个事务可能由很多操作构成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。

## 1.2 产生

分布式事务的核心在于保证不同系统的数据一致性。比较应用SOA化以后，各个模块都有自己的数据库。分布式事务就是保证不同数据库的数据一致性。

## 1.3 解决方案

所有的方案基本都是2PC的变型与增强，先了解下2PC的工程实践。[两阶段提交的工程实践](https://zhuanlan.zhihu.com/p/22594180)。

### 1.3.1 X/Open DTP模型

此方案主要问题是协议和实现都比较复杂，且效率较低，不适合高并发场景。

### 1.3.2 eBay 事件队列方案——最终一致性  

* 将分布式事务变成 本地事务+异步事件通知。将需要分布式处理的任务通过消息队列来异步执行。
* 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，然后消息发送给MQ。如果消息发送失败，会进行重试发送。
* 消费者消费消息并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。
* 缺点是有些不适合异步执行的任务（有可能业务层面失败），需要给生产方发送一个业务补偿消息，否则不适合此方案。


### 1.3.3 TCC

//TODO

# 2 基于消息的分布式事务

## 2.1 业务方实现

一些消息队列本身不支持事务消息（Kafka,rabbitMQ），但只要消息队列保证消息可靠，业务方就可以通过MQ自己实现分布式事务。自己实现的话步骤如下：

* 将涉及分布式系统的的操作A和操作B所在的应用，分别定义成某个主题的生产者与消费者。
* 在生产者的数据库中加一个事务状态表，将本地操作与此表状态的更新放在同一个本地事务中，这样就维持了数据的一致性。其中一个字段记录事务状态，一个字段记录消息的投递状态。
* 对于本地回滚的事务，不进行投递。
* 对于本地commit的事务，则向消息队列投递消息，且必须得到消息队列投递成功的响应，然后更改数据库中的消息投递状态。
* 对于已经commit的事务，如果消息投递状态还没改变，则起线程循环投递，直到成功。
* 其它数据库的更新操作则订阅对应的消息，由于消息队列保证不丢消息，所以一定能保证最终一致性。注意消费者需要自己保证幂等。


## 2.2 事务消息

另一个方案就是采取自身支持事务消息的MQ。事务消息的基本思路如下图所示。

![分布式事务](http://ovor60v7j.bkt.clouddn.com/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.png)

显然，这个方案和2.1中的方案原理上并没有太大区别，只是把需要业务自己做的轮询变成了服务端的回查。

* 对于业务方来说，减少了开发难度。
* 对于多个需要事务消息的应用，不用重复造轮子。
* 对于服务端，交互次数增多，增加了部分压力。

## 3 设计与实现

### 3.1 交互流程

![分布式事务](http://ovor60v7j.bkt.clouddn.com/feedback.png)


事务消息交互流程如下：

1. 生产者向broker发送消息；
2. broker将消息以及prepare命令持久化成功之后，向发送方 ACK 确认消息已经发送成功。
3. 生产者开始执行本地事务逻辑。
4. 生产者根据本地事务执行结果向broker 发送Commit 或是 Rollback，broker收到 Commit 则为消息建立索引，消费者最终消费；broker收到 Rollback 状态则结束事务，消费者将不会接受该消息。
5. 在断网或者是应用重启的特殊情况下，Commit 或是 Rollback未达到broker或者未能写盘成功，经过固定时间后 broker 将对该消息发起消息回查。
6. 生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
7. 生产者根据检查得到的本地事务的最终状态后再次提交Commit 或是 Rollback。

其中1-4属于正常流程，而5-7属于异常情况下的回查机制（后文称为Feedback机制）。

### 3.2 客户端设计

客户端设计比较简单，只需解决以下问题

* 如何设计生产接口
* 如何设计回查的接口
* 如何保证事务ID的唯一性
* 宕机了如何知道哪些事务没有提交

### 3.2.1 生产接口设计

为了减少业务方的自由度和工作量，生产的流程的prepare,commit,rollback操作由提供出去的SDK自己定义。所以提供回调供业务方实现本地事务的业务逻辑，返回值是本地事务处理的结果。客户端框架程序根据返回值决定commit还是rollback.调用方式如下(此部分设计参考RocketMQ):


```
producer.sendMessageInTransaction(msg, new LocalTransactionExecuter() {
                                @Override
                                public TransactionState executeLocalTransactionBranch(Message msg) {
                                    //本地事务，返回值为事务成功或失败
                                }
                            })
```
接口的返回值为事务的成功或失败，定义如下

```
public enum TransactionState {
    //事务准备
    PREPARE,
    //事务已提交
    COMMITTED,
    //事务已回滚
    ROLLBACK,
    //未知状态
    UNKNOWN;
}
```

### 3.2.2 回查接口设计

回查接口是服务端发现事务处于不确定的状态后，向客户端进行查询。

```
public interface TxStatusQuerier {
    /**
     * 查询事务状态
     *
     * @param txId    事务ID
     * @param queryId 查询ID
     * @return 事务状态
     */
    TransactionState queryStatus(String txId, String queryId);
}
```
返回值为事务的状态，缺点是要像业务方暴露事务的状态。

## 3.2.3 事务ID

事务ID作为唯一标识，支持业务方自定义。
如果用户不进行定义则为  “客户端版本 - 客户端IP - 客户端启动时间 - 进程号 - 连接自增数 - 事务自增数”。

## 3.2.4 宕机恢复

如果客户端宕机了，怎么判断到底有哪些事务处于什么状态呢？有一种解决方案叫做恰好不需要解决。
客户端以正常逻辑执行事务消息的时候，一个线程只能同时处理一个事务消息，事务相关信息都存储在线程上下文中，因此无需进行存储。
如果客户端发生异常，由于服务端必须对每个事务消息的状态进行存储，所以逻辑上由服务端进行反向查询就可以，客户端无需维持事务消息的状态。

### 3.3 服务端设计

进行服务端设计时，从功能上考虑，必须要做到：

* 事务消息保证可靠，即一旦回复客户端提交或者回滚，就必须在任何情况下保持一致。
* 对于未完成的事务，服务端在任何情况下都必须回查客户端，不能自行进行处理。

从功能上来说，要做到这个保证，就要求我们对于每个操作都进行同步刷盘，并记录log。并且在发生异常的时候，内存里保存的事务上下文丢失，要能根据日志进行恢复。但是由于FMQ的存储模型设计采用顺序刷盘，如果同步写操作日志，不可避免的要进行磁头的调度。如果要保证性能，就只能从以下方案里进行设计：

1. 采用SSD代替HDD。由于SSD随机写比HDD iops高百倍以上，基本能满足性能要求。
2. 将操作日志包装成消息进行存储，系统只对实际的消息存储文件进行同步刷盘。
3. 采用磁盘以外的可靠存储进行日志持久化（例如数据库），不破坏原有存储结构。

方案1经济成本较高，对于大规模部署的系统目前使用经济负担较大。
方案2实现复杂，且很大改变了原有的存储逻辑，命令和数据混杂在一起。但是与原方案兼容性较好。
方案3实现简单，不破坏原有存储结构，但是引入了第三方依赖。

目前暂时按方案2进行设计。

### 3.3.1 基本流程

存储的消息总共分为以下几种类型


| 消息类型    | 描述       |
|:----------:|:-------------:|
|MESSAGE|非事务消息|
|PREPARE|命令字，无实际消息内容|
|PRE_MESSAGE|prepare阶段预存的消息，保存消息体|
|REF_MESSAGE|指向PRE_MESSAGE的指针，无实际消息内容|
|TX_Message|REF_MESSAGE复制body以后刷盘的消息|
|COMMIT|命令字，无实际消息内容|
|ROLLBACK|命令字，无实际消息内容|


### 3.3.2 Prepare

* 判断事务是否超出限制个数
* Prepare命令字刷盘
* 将事务添加到事务管理器
* BrokerPreMessage刷盘
	* 选择投递的队列
	* preMessage刷盘
	* 为每一条消息建立BrokerRefMessage
	* 归档
	* 内存prepare保存所有消息的refMessage
* 同步日志给从节点

以上流程如果出现异常则直接执行回滚。

### 3.3.3 Commit

* 逐条refMessage刷盘
	* 判断和BrokerPreMessage还是不是一个文件
	* 判断消息大小是否小于 事务需要建索引消息下限，小于的话需要当做txMessage刷盘
	* 如果与pre不处于同一个文件 || 文件剩余空间不能写下 ，也需要当做txMessage刷盘
	* 如果需要当做txMessage刷盘
		* 复制一份原来的消息
		* 当做TYPE_TX_MESSAGE消息进行刷盘
	* 如果不需要更改消息类型，ref_message刷盘
	* 异步建立索引文件
* commitMessage刷盘
* 事务ID移除
* 同步日志给从节点



### 3.3.4 RollBack

* BrokerRollback刷盘
* 事务ID移除
* 同步日志给从节点

这里回滚很简单，因为只有建立索引的消息才会被消费掉，所以执行回滚操作的时候，只需要记录下命令字并且从事务管理器里面移除事务ID就可以。没有建立索引，相当于消息被回滚了。


### 3.3.5 Feedback

#### 3.3.5.1 client

* 每个app+topic唯一对应一个TopicFeedback
* TopicFeedback里保存map<BrokerGroup,GroupFeedback>
* GroupFeedback
	* 独立线程，按照100ms间隔不断向服务端发TxFeedback命令（5s超时）。如果更新成功，则变更TxFeedback状态。
	* 如果feedback带事务ID，根据状态进行commit或者rollback。
	* 锁定并获取未提交的事务返回给客户端
	* 没有锁定的事务则挂起（长轮询）
	
#### 3.3.5.2 broker

* 对应的key(topic+producer)如果有未完成事务，返回事务ID，查询对应状态。
* 没有未完成事务，对请求进行长轮询管理。

### 3.3.6 Recovery

在服务器发生宕机以后，如何恢复事务的管理呢？主要思想是采用checkPoint + redo log

#### 3.3.6.1 检查点

先回顾下checkPoint在FMQ中的作用。由于FMQ采用日志文件同步刷盘，索引文件异步刷盘的方式。在非正常关闭时，内存中索引文件的最新值未能及时刷盘，就有可能出现日志文件进度大于索引文件的情况。此时系统就要从日志文件中重建索引，恢复丢失的数据。
如果从头恢复的话数据量较大，启动时间较长。checkPoint主要是为了解决这个问题，只要从这个记录点开始恢复索引文件就行。
非事务消息阶段，checkpoint记录的是日志的最大写入位置，且时序是 ：
  
1. checkpoint获取日志最大位置
2. 队列文件刷盘
3. checkpoint文件刷盘

这样checkPont的值是在队列文件刷盘以前，但是刷盘这个操作本身在队列文件刷盘以后。恢复的时候先加载队列索引文件，然后从checkPoint文件记录的日志位置开始重建索引。因为checkPoint点的数据获取在索引队列刷盘之前，这样就保证不会丢失索引数据。 

在事务消息中，因为所有的控制字都写在日志文件里，要重建事务上下文就必须重放日志（redo log）。所以checkpoint的值变成了min(日志刷盘位置,最小未完成的事务位置)。这样故障恢复的时候执行redo，才能保证所有未完成的事务都被重新加入内存的事务管理中。

#### 3.3.6.2 恢复

从checkpoint对应的日志位置开始重建索引和事务管理，对于不同消息主要处理逻辑如下表。

| 消息类型    | 恢复动作       |
|:----------:|:-------------|
| MESSAGE |  /   |  
| PREPARE |  开启事务，将事务ID加入管理器   |  
| PRE_MESSAGE| 1.检查消息体合法性<br/>2.建立REF_MESSAGE    | 
| REF_MESSAGE|  建立队列索引   | 
| TX_MESSAGE|1.检查消息体合法性<br/>2.建立队列索引|
| COMMIT|   移除事务  | 
| ROLLBACK| 移除事务    | 

### 3.3.7 故障恢复正确性分析

一条事务消息在服务端的同步刷盘过程如下，我们逐次分析如果在每个阶段宕机，服务端如何恢复以及客户端如何处理。

![分布式事务流程](http://ovor60v7j.bkt.clouddn.com/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.png)

#### 3.3.7.1 prepare flush前宕机

对应图中阶段1。  
此时服务端并没有开始写事务日志，启动以后不会做任何处理。  
客户端没有收到服务端ack，prepare阶段失败，进行回滚.

#### 3.3.7.2 preMessage flush前宕机

对应图中阶段2。 
 
* 客户端由于prepare异常，进行了回滚。  
* 服务端重启后解析日志发现prepare命令，进行redo，将事务ID加入管理器。Feedback模块进行回查，发现客户端已经回滚，移除此事务。

#### 3.3.7.3 preMessage flush过程中宕机

由于一次事务可以有多条消息，可能某些消息刷盘成功，某些没完成。由于此情况下客户端会进行回滚，Feedback最终发现事务执行失败，所以不会有影响。

#### 3.3.7.4 refMessage flush 前宕机

对应图中3阶段prepare ack之前或者之后的时间段，以及收到commit还未写磁盘的时间段。
同3.3.7.2情况，区别只在与多恢复preMessage导致内存中存在refMessage。此时Feedback模块进行回查，发现客户端commit成功，继续执行commit操作。

#### 3.3.7.5 refMessage flush 过程中宕机

* 此时由于refMessage已经写了一部分，对于写成功的部分在恢复时已经成功建立了索引。
* 但是未写成功部分，则不会建立索引被消费掉。但是由于在恢复preMessage时是全量恢复的，所以内存里是全量信息。
* Feedback模块进行回查，发现已经commit，重新执行。

此处存在风险在于，在Feedback补偿的窗口期，可能出现一部分消息已经被投递，另一部分还没投递的情况。


#### 3.3.7.6 commit flush前宕机

和3.3.7.5的区别在于可以全量建立消费索引。但是由于服务端并不知道是否commit完成，还是会触发Feedback回查。


#### 3.3.7.7 commit flush后宕机

* 由于所有的流程都已经完成，redo log以后就相当于完成了事务，不会触发回查。客户端也并不关心commit ack。

* 实现时客户端可以选择不需要服务端回复commit ack以减少交互。

#### 3.3.7.8 roolback flush前后宕机

* roolback flush前宕机，触发回查，进行回滚
* roolback flush后宕机，redo恢复，不需要回查


## 3.4 工程实现细节

#### 宕机了如何维护内存的事务管理器

* 日志进行重放

#### refMessage作用

* 事务消息支持单个事务多条消息，refMessage实际上是起到了索引的作用

#### refMessage为什么要刷盘以及和原消息不在一个文件时复制内容

* 磁盘清理按照文件为维度删除
* 没有建立索引的消息可能被删除，重新复制消息可以防止原消息已经被清理

#### commit阶段先持久化refMessage还是先持久化commit命令字

* 先持久化refMessage，再持久化commit。否则存在多条refMessage时，如果宕机恢复，不知道是否需要回查

####  由于prepare阶段没有建立索引，如果2天还没有commit，原始文件被删除了怎么办

* 清理逻辑加上比较ack的最小值与checkPoint记录的recoveryOffset。这样未被完成的事务不会被删除。（这样是否还有必要复制消息内容到refMessage?）

#### 是否支持消息回溯

* 逻辑上消息回溯只涉及索引表，不涉及日志修改。

## 4 RocketMQ实现

* table & redo log是否同步刷盘，对于效率的影响
* 修改commit log导致脏页的问题
//TODO
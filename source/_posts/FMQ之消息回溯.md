---
title: FMQ之消息回溯
date: 2018-08-21 16:55:44
tags:
- 中间件
- 消息队列
categories: 编程
comments: true
---
本文介绍了FMQ的消息回溯功能的设计及其实现。实际实现为根据时间和队列位置进行消费位置的设置，以达到重新消费消息或者跳过部分消息的功能。
<!--more-->

## 1 需求分析

在实际生产环境中，经常有业务需要将已经消费过的消息重新消费；有另外一些业务则因为某些原因，已经对积压的消息不再感兴趣，希望能对消息进行跳过处理。针对这两种场景，有了消息回溯以及跳过的需求。

### 1.1 功能维度

从功能维度上来说，分为2块：

* 按时间进行回溯，即用户指定时间点，消费从这个时间点开始重新消费。
* 按照消费位置进行回溯，即从某个偏移量开始继续向后消费。

### 1.2 操作维度

对于操作维度，分为对于单个队列的操作和对所有队列的批量操作。

## 2 设计

### 2.1 交互设计

在进行交互设计之前，有几个问题首先需要确定。

* 由于生产环境对于积压的消息不会在超期后自动清理，需要人工进行清理。那么如果数据没被清理，回溯的最长时间(位置)是按照对外保证数据存储的最长时间（位置）还是只要实际磁盘存在的数据都允许回溯？
	* 取磁盘实际存在的数据，只要数据存在，尽可能的允许业务进行回溯。
* 如果回溯的时间点没有消息精确对应，取前一条的位置还是后一条的位置？
	* 如果不存在某条消息精确对应此时间点，则回溯到此时间点后的第一条。

### 2.1.1 按时间单队列回溯

### 2.1.2 按时间批量回溯

### 2.1.3 按位置单队列回溯

### 2.1.4 按位置批量回溯

### 2.2 后台设计


## 3 实现


### offset

* subscribeOffset 消费者接入开始消费的位置
* ackOffset 消费者已经消费的位置
* acks 消费区间

#### queueOffset.acknowledge

* 更新acks值
* 判断ackOffset是否需要更新.满足一下两个条件之一
	* ackOffset > subscribeOffset （ackOffset == subscribeOffset 说明未被消费过，ackOffset < subscribeOffset 说明消费过程中取消订阅又重新订阅，然后与offsetManager的createOffset发生并发问题，见异常情况1）
	* headSequence.contains(target.getSubscribeOffset().get() + ConsumeQueue.CQ_RECORD_SIZE) 不符合这条说明区间最开始的都没ack，不需要更新ack值
	
	
### 异常情况

* 先取消订阅，再订阅，此时正好发生ack，发现subscribeOffset由于订阅被置为maxOffset，ackOffset尚未来得及被重置，则ackOffset<subscribeOffset.此时应该正常。